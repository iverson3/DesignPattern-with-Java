让我们对问题重新描述一下：我们已经有了一个关于错误的类层次结构，
现在我们需要在不改变这个类层次结构的前提下允许我们增加对于这个类层次的新的处理方法。
听起来很耳熟吧，不错，这正是过于visitor设计模式的意图的描述。
通过对于该模式动机的分析，我们很容易知道，要想使用visitor模式，
需要定义两个类层次：一个对应于接收操作的元素的类层次（就是我们的错误类），
                                  另一个对应于定义对元素的操作的访问者（就是我们的对于错误的不同处理方法）。
这样，我们就转换了问题视角，即把需要不同的错误处理方法的问题转变为需要不同的错误处理类，
这样的结果就是我们可以通过增加新的模块（类）来增加新的错误处理方法，
而不是通过增加新的错误处理方法（这样做，就势必要修改已经存在的类）。

一旦到了这一部，下面的工作就比较简单了，因为visitor模式已经为我们搭建了一个设计的上下文，
此时我们就可以关注visitor模式的实现部分来指导我们下面的具体实现了。
下面仅仅给出最终的程序结构的UML图以及代码示例，其中忽略了错误类中的属于错误本身的方法，
各个具体的错误处理方法通过这些方法和具体的错误类对象交互，来完成各自的处理功能。